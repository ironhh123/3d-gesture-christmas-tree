<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>CHRISTMAS - PHOTOS TREE</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; font-family: sans-serif; cursor: none; }
        
        #info {
            position: absolute; top: 10px; left: 10px; color: #B8860B; 
            background: rgba(0,0,0,0.85); padding: 15px; border-radius: 8px;
            pointer-events: none; user-select: none; border: 1px solid #B8860B;
            box-shadow: 0 0 15px rgba(184, 134, 11, 0.2);
            z-index: 200;
        }
        h3 { margin: 0 0 5px 0; color: #fff; font-size: 16px; }
        p { margin: 5px 0; font-size: 14px; color: #ddd; }
        
        #video-container {
            position: absolute; bottom: 20px; right: 20px;
            width: 160px; height: 120px;
            border: 2px solid rgba(184, 134, 11, 0.5); 
            border-radius: 8px; overflow: hidden; z-index: 10;
            opacity: 0.5;
            display: none;
        }
        #webcam { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        
        #loading {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #B8860B; font-size: 20px; text-align: center;
            pointer-events: none; letter-spacing: 1px;
            z-index: 200;
        }

        #selection-tip {
             position: absolute; top: 15%; left: 50%;
             transform: translateX(-50%);
             color: #fff; background: rgba(0,0,0,0.6);
             padding: 10px 20px; border-radius: 30px;
             display: none; pointer-events: none;
             border: 1px solid #B8860B;
             font-size: 16px; text-shadow: 0 0 5px gold;
             z-index: 100;
        }

        #hand-cursor {
            position: absolute; width: 40px; height: 40px;
            border: 2px solid rgba(255, 255, 255, 0.8); border-radius: 50%;
            background: rgba(255, 215, 0, 0.1);
            box-shadow: 0 0 15px #ffd700;
            pointer-events: none; z-index: 999;
            transform: translate(-50%, -50%);
            display: none; transition: width 0.2s, height 0.2s;
        }
        .cursor-active {
            width: 60px !important; height: 60px !important;
            border-color: #ffd700 !important;
            background: rgba(255, 215, 0, 0.2) !important;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

    <div id="loading">âœ¨ æ­£åœ¨é›•åˆ»é‡‘è‰²æ–‡å­—...<br>è¯·æˆäºˆæ‘„åƒå¤´æƒé™</div>
    <div id="info">
        <h3>ğŸ„ é­”æ³•æ“ä½œæŒ‡å—</h3>
        <p>âœŠ <b>æ¡æ‹³</b>ï¼šèšæ‹¢æˆæ ‘</p>
        <p>ğŸ– <b>å¼ æ‰‹</b>ï¼šæ•£å¼€æµè§ˆ</p>
        <p>ğŸ‘† <b>æ‚¬åœ</b>ï¼šé€‰ä¸­ç…§ç‰‡æŸ¥çœ‹</p>
    </div>
    
    <div id="video-container"><video id="webcam" playsinline></video></div>
    <div id="selection-tip"></div>
    <div id="hand-cursor"></div>

    <script>
        // ================= é…ç½®åŒº =================
        const PHOTO_COUNT = 100;     
        const ORNAMENT_COUNT = 450;
        const IMAGE_URLS = ['./assets/assets/1.png', './assets/2.png', './assets/3.png', './assets/4.png', './assets/5.png', './assets/6.png', './assets/7.png', './assets/8.png', './assets/9.png', './assets/10.png', './assets/11.png', './assets/12.png', './assets/13.png', './assets/14.png', './assets/15.png', './assets/16.png'];
        const COLOR_GOLD = 0xB8860B; // æš—é‡‘è‰²
        const COLOR_RED  = 0x8B0000;
        const COLOR_GREEN= 0x006400;

        // ================= å…¨å±€å˜é‡ =================
        let scene, camera, renderer, composer;
        let particles = []; 
        let ornaments = []; 
        let starMesh, textMesh; // æ–°å¢ textMesh
        let raycaster = new THREE.Raycaster(); 
        let mouse = new THREE.Vector2(); 
        
        let selectionTip = document.getElementById('selection-tip');
        let cursor = document.getElementById('hand-cursor');

        // çŠ¶æ€
        let isTreeForm = true;      
        let treeRotationSpeed = 0.002; 
        let activePhotoIndex = -1;  

        // ================= åˆå§‹åŒ– =================
        function initScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            scene.fog = new THREE.FogExp2(0x000000, 0.0015);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 150); // ç¨å¾®æ‹‰è¿œä¸€ç‚¹ä»¥ä¾¿çœ‹åˆ°é¡¶éƒ¨çš„æ–‡å­—
            camera.lookAt(0, 40, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0x444444, 1);
            scene.add(ambient);
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(0, 50, 100);
            scene.add(mainLight);
            const goldLight = new THREE.PointLight(COLOR_GOLD, 2.0, 400);
            goldLight.position.set(0, 40, 0);
            scene.add(goldLight);

            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.7, 0.3, 0.1);
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            createElements();
            createStar();
            createTitleText(); // åˆ›å»ºæ–‡å­—

            window.addEventListener('resize', onWindowResize);
            animate();
        }

        // --- æ–°å¢ï¼šåˆ›å»º MERRY CHRISTMAS æ–‡å­— ---
        function createTitleText() {
            const loader = new THREE.FontLoader();
            // åŠ è½½ Helvetiker å­—ä½“
            loader.load('https://unpkg.com/three@0.128.0/examples/fonts/helvetiker_bold.typeface.json', function (font) {
                
                const textGeo = new THREE.TextGeometry('MERRY CHRISTMAS', {
                    font: font,
                    size: 8,       // å­—å·
                    height: 1,     // åšåº¦
                    curveSegments: 12,
                    bevelEnabled: true,
                    bevelThickness: 0.2,
                    bevelSize: 0.1,
                    bevelSegments: 5
                });

                // å±…ä¸­æ–‡å­—
                textGeo.computeBoundingBox();
                const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
                textGeo.translate(centerOffset, 0, 0);

                const textMat = new THREE.MeshStandardMaterial({
                    color: COLOR_GOLD, // ä½¿ç”¨æš—é‡‘
                    emissive: COLOR_GOLD,
                    emissiveIntensity: 0.8, // å¾®å¾®å‘å…‰
                    metalness: 0.8,
                    roughness: 0.2
                });

                textMesh = new THREE.Mesh(textGeo, textMat);
                // æ”¾åœ¨æ ‘é¡¶æ˜Ÿæ˜Ÿä¸Šæ–¹
                textMesh.position.set(0, 90, 0); 
                scene.add(textMesh);
            });
        }

        function createElements() {
            const textureLoader = new THREE.TextureLoader();
            const textures = IMAGE_URLS.map(url => textureLoader.load(url));

            const photoGeo = new THREE.PlaneGeometry(6, 6);
            const frameGeo = new THREE.PlaneGeometry(6.8, 6.8);
            const frameMat = new THREE.MeshStandardMaterial({ color: COLOR_GOLD, metalness: 1.0, roughness: 0.2 });

            for (let i = 0; i < PHOTO_COUNT; i++) {
                const photoMat = new THREE.MeshStandardMaterial({ map: textures[i % textures.length], side: THREE.DoubleSide });
                const group = new THREE.Group();
                group.add(new THREE.Mesh(photoGeo, photoMat));
                const frame = new THREE.Mesh(frameGeo, frameMat);
                frame.position.z = -0.1;
                group.add(frame);

                setupPosition(group, i, PHOTO_COUNT, 100, 55, false);
                group.userData.id = i;
                group.userData.baseScale = 1.0;
                scene.add(group);
                particles.push(group);
            }

            const orbGeo = new THREE.SphereGeometry(1.6, 24, 24);
            for (let i = 0; i < ORNAMENT_COUNT; i++) {
                const r = Math.random();
                let c = (r < 0.7) ? COLOR_GOLD : (r < 0.85 ? COLOR_RED : COLOR_GREEN);
                const mat = new THREE.MeshStandardMaterial({ color: c, emissive: c, emissiveIntensity: 0.4, roughness: 0.2, metalness: 0.6 });
                const mesh = new THREE.Mesh(orbGeo, mat);
                setupPosition(mesh, i, ORNAMENT_COUNT, 110, 60, true);
                mesh.userData.baseIntensity = 0.3 + Math.random() * 0.4;
                mesh.userData.sparkleSpeed = Math.random() * 0.1 + 0.05;
                scene.add(mesh);
                ornaments.push(mesh);
            }
        }

        function setupPosition(obj, index, total, height, maxRadius, isOrb) {
            const yNorm = index / total;
            const treeY = height * 0.6 - (yNorm * height);
            const radius = Math.pow(yNorm, 0.85) * maxRadius * (isOrb ? Math.random() * 0.3 + 0.9 : 1);
            const angle = index * (isOrb ? 0.5 : 1.1) + (isOrb ? Math.random() * Math.PI : 0);
            
            obj.userData.treePos = new THREE.Vector3(Math.cos(angle)*radius, treeY, Math.sin(angle)*radius);
            obj.userData.scatterPos = new THREE.Vector3((Math.random()-0.5)*400, (Math.random()-0.5)*300, (Math.random()-0.5)*200);
            obj.userData.velocity = 0.02 + Math.random() * 0.03;
            obj.position.copy(obj.userData.scatterPos);
        }

        function createStar() {
            const star = new THREE.Mesh(new THREE.OctahedronGeometry(6, 0), new THREE.MeshStandardMaterial({ color: COLOR_GOLD, emissive: COLOR_GOLD, emissiveIntensity: 2.0 }));
            star.position.set(0, 75, 0);
            starMesh = star;
            scene.add(star);
        }

        // ================= åŠ¨ç”»ä¸äº¤äº’æ ¸å¿ƒ =================
        function animate(time) {
            requestAnimationFrame(animate);

            // æ—‹è½¬
            scene.rotation.y += isTreeForm ? treeRotationSpeed : treeRotationSpeed * 0.1;
            
            // æ˜Ÿæ˜Ÿåå‘æ—‹è½¬
            if(starMesh) starMesh.rotation.y -= 0.02;

            // æ–‡å­—å§‹ç»ˆæœå‘æ‘„åƒæœº (Billboardæ•ˆæœ) æˆ–è€…è·Ÿéšæ ‘æ—‹è½¬
            // è¿™é‡Œæˆ‘ä»¬è®©æ–‡å­—è·Ÿéšæ ‘æ—‹è½¬ï¼Œä½†ä¸ºäº†ä¿è¯èƒ½çœ‹æ¸…ï¼Œæˆ‘ä»¬åªè®©å®ƒè‡ªè½¬ä¸€ç‚¹ç‚¹ï¼Œæˆ–è€…å¹²è„†ä¿æŒæœå‘å‰æ–¹
            // æ–¹æ¡ˆï¼šè®©æ–‡å­—ä½œä¸ºä¸€ä¸ª Object3D ä¹Ÿæ˜¯ scene çš„å­ç‰©ä½“ï¼Œå®ƒä¼šè·Ÿç€ scene è½¬ã€‚
            // ä½†å¦‚æœæƒ³è¦å®ƒå§‹ç»ˆæ­£é¢æœå‘è§‚ä¼—ï¼Œéœ€è¦æ‰‹åŠ¨è®¾ç½® lookAt
            if (textMesh) {
                // å¦‚æœæƒ³è¦æ–‡å­—è·Ÿç€æ ‘è½¬ï¼Œä»€ä¹ˆéƒ½ä¸ç”¨åš (å› ä¸ºå®ƒ add è¿›äº† scene)
                // å¦‚æœæƒ³è¦æ–‡å­—å§‹ç»ˆé¢å‘è§‚ä¼— (æ¨è):
                // æˆ‘ä»¬éœ€è¦æŠµæ¶ˆ scene çš„æ—‹è½¬
                textMesh.position.set(0, 90, 0); // ç¡®ä¿ä½ç½®æ­£ç¡®
                // ä¸‹é¢è¿™è¡Œè®©æ–‡å­—è™½ç„¶ä½ç½®è·Ÿç€åœºæ™¯è½¬ï¼Œä½†è„¸å§‹ç»ˆå¯¹ç€ç›¸æœº
                // å®é™…ä¸Š textMesh æ˜¯ scene çš„å­å¯¹è±¡ï¼Œscene åœ¨è½¬ã€‚
                // ç®€å•çš„åšæ³•æ˜¯ï¼šæ¯å¸§è®¾å®š textMesh çš„ä¸–ç•Œæ—‹è½¬ç­‰äºç›¸æœºçš„æ—‹è½¬ (å–å)
                // æˆ–è€…ç®€å•ç‚¹ï¼šè®©å®ƒä¹Ÿä¸åŠ¨ã€‚
                
                // ä½†ä¸ºäº† 3D æ•ˆæœï¼Œè·Ÿç€æ ‘è½¬å…¶å®æŒºå¥½çœ‹çš„ã€‚
                // åªæ˜¯ä¸ºäº†æ˜“è¯»æ€§ï¼Œæˆ‘ä»¬å¯ä»¥è®©å®ƒè½¬å¾—æ…¢ä¸€ç‚¹ï¼Œæˆ–è€…ä¸åšç‰¹æ®Šå¤„ç†ã€‚
                // è¿™é‡Œä¸åšç‰¹æ®Šå¤„ç†ï¼Œè®©å®ƒåƒæ ‘é¡¶çš„è£…é¥°ä¸€æ ·æ—‹è½¬ã€‚
            }

            particles.forEach(group => {
                let targetPos, targetScale;
                const isSelected = (!isTreeForm && group.userData.id === activePhotoIndex);

                if (isSelected) {
                    const worldTarget = new THREE.Vector3(0, 0, -30).applyMatrix4(camera.matrixWorld);
                    scene.worldToLocal(worldTarget); 
                    
                    targetPos = worldTarget;
                    targetScale = 5.0; 
                    
                    group.children[1].material.emissive.setHex(0xffffff);
                    group.children[1].material.emissiveIntensity = 2.0;
                    
                    group.lookAt(camera.position);
                    group.position.lerp(targetPos, 0.1); 
                    
                } else {
                    targetPos = isTreeForm ? group.userData.treePos : group.userData.scatterPos;
                    targetScale = group.userData.baseScale;
                    
                    group.children[1].material.emissive.setHex(0x221100);
                    group.children[1].material.emissiveIntensity = 0.5;
                    
                    group.lookAt(camera.position);
                    group.position.lerp(targetPos, group.userData.velocity);
                }
                
                const currentScale = group.scale.x;
                const newScale = THREE.MathUtils.lerp(currentScale, targetScale, 0.1);
                group.scale.set(newScale, newScale, newScale);
            });

            ornaments.forEach(mesh => {
                const target = isTreeForm ? mesh.userData.treePos : mesh.userData.scatterPos;
                mesh.position.lerp(target, mesh.userData.velocity);
                const flicker = Math.sin(time * mesh.userData.sparkleSpeed + mesh.id) * 0.5 + 0.5;
                const spike = Math.random() > 0.98 ? 3.0 : 0; 
                mesh.material.emissiveIntensity = mesh.userData.baseIntensity + flicker * 0.3 + spike;
            });

            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // ================= æ‰‹åŠ¿æ§åˆ¶é€»è¾‘ =================
        const loadingElement = document.getElementById('loading');
        const videoElement = document.getElementById('webcam');

        function onHandsResults(results) {
            loadingElement.style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const thumb = landmarks[4];
                const index = landmarks[8];
                
                const pinchDist = Math.hypot(thumb.x - index.x, thumb.y - index.y);
                const isOpenHand = (pinchDist > 0.25);

                if (isOpenHand) {
                    isTreeForm = false; 
                    cursor.style.display = 'block';
                    cursor.classList.add('cursor-active'); 
                    updateCursorAndCheckHover(index); 
                } else {
                    isTreeForm = true; 
                    cursor.style.display = 'none';
                    activePhotoIndex = -1; 
                    selectionTip.style.display = 'none';
                }

                treeRotationSpeed = (0.5 - landmarks[0].x) * 0.15; 

            } else {
                isTreeForm = true;
                cursor.style.display = 'none';
                activePhotoIndex = -1;
                selectionTip.style.display = 'none';
            }
        }

        function updateCursorAndCheckHover(point) {
            const cursorX = (1 - point.x) * window.innerWidth;
            const cursorY = point.y * window.innerHeight;

            cursor.style.left = `${cursorX}px`;
            cursor.style.top = `${cursorY}px`;

            const ndcX = (1 - point.x) * 2 - 1; 
            const ndcY = -(point.y * 2) + 1; 
            mouse.set(ndcX, ndcY);
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(particles, true);

            if (intersects.length > 0) {
                let targetGroup = intersects[0].object;
                while(targetGroup.parent && !targetGroup.userData.hasOwnProperty('id')) {
                    targetGroup = targetGroup.parent;
                }
                
                if (targetGroup.userData.id !== undefined) {
                    if (activePhotoIndex !== targetGroup.userData.id) {
                        activePhotoIndex = targetGroup.userData.id;
                        selectionTip.style.display = 'block';
                        selectionTip.innerText = `ğŸ MERRY CHRISTMAS! æŸ¥çœ‹ç…§ç‰‡ #${activePhotoIndex + 1}`;
                    }
                }
            }
        }

        if (typeof Hands === 'undefined') {
             alert("MediaPipe åº“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œï¼");
        } else {
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
            hands.onResults(onHandsResults);
            
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 320, height: 240
            });
            cameraUtils.start();
        }
        
        initScene();

    </script>
</body>
</html>      